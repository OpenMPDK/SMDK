package packageinfo

import (
	"bufio"
	"encoding/json"
	"fmt"
	"os"
	"strconv"
	"strings"

	"samsung/socmmd/internal/consts"

	"sigs.k8s.io/controller-runtime/pkg/client"
)

const (
	adviceMsg = "if you have a local test environment, set env as follows before running process: OPER_RUN_MODE=test"
)

// operator properties metadata generated by operator framework
type operProps struct {
	Properties []struct {
		Type  string `json:"type"`
		Value struct {
			PackageName string `json:"packageName"`
			Version     string `json:"version"`
		} `json:"value"`
	} `json:"properties"`
}

type packageinfo struct {
	namespace   string
	nameVersion string
	rhelVersion float64
}

var info = packageinfo{}

// Init
func Init(c client.Client) error {
	if isLocalRuntime() {
		info.namespace = "default"
		info.nameVersion = "test.operator.com.v0.0.1"
		info.rhelVersion = 9.2

	} else {
		if os.Getenv(consts.EnvOperNamespace) == "" {
			return fmt.Errorf("not found EnvOperNamespace error(%s)", adviceMsg)
		} else if os.Getenv(consts.EnvOperProps) == "" {
			return fmt.Errorf("not found EnvOperProps error(%s)", adviceMsg)
		}

		// namespace
		info.namespace = os.Getenv(consts.EnvOperNamespace)

		// nameVersion
		propsStr := os.Getenv(consts.EnvOperProps)
		props := operProps{}
		if err := json.Unmarshal([]byte(propsStr), &props); err != nil {
			return fmt.Errorf("unmarshal operator props error: [%s: %s][%s: %s]: %w",
				consts.EnvOperNamespace, info.namespace,
				consts.EnvOperProps, propsStr,
				err,
			)
		}
		for _, v := range props.Properties {
			if v.Type == "olm.package" {
				info.nameVersion = fmt.Sprintf("%s.v%s", v.Value.PackageName, v.Value.Version) // e.g) socmmd.v0.0.1
				break
			}
		}

		// rhel version
		rhelVersion, err := getRhelVersion()
		if err != nil {
			return err
		}
		info.rhelVersion = rhelVersion
	}

	if info.namespace == "" {
		return fmt.Errorf("not found namespace error(%s)", adviceMsg)
	} else if info.nameVersion == "" {
		return fmt.Errorf("not found package version error(%s)", adviceMsg)
	} else if info.rhelVersion == 0.0 {
		return fmt.Errorf("not found rhel version error(%s)", adviceMsg)
	}

	return nil
}

// getRhelVersion
func getRhelVersion() (float64, error) {
	version := 0.0

	file, err := os.Open("/host/etc/os-release")
	if err != nil {
		return version, fmt.Errorf("host os-release file open error(%s)", err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		if !strings.HasPrefix(line, "RHEL_VERSION=") {
			continue
		}

		slice := strings.Split(line, "=")
		if len(slice) != 2 {
			return version, fmt.Errorf("host os-release version split error(text line: '%s')", line)
		}

		v := strings.ReplaceAll(slice[1], "\"", "")
		if version, err = strconv.ParseFloat(v, 64); err != nil {
			return version, fmt.Errorf("host os-release version parsing error(%s)", err)
		}
	}

	if err := scanner.Err(); err != nil {
		return version, fmt.Errorf("host os-release file read error(%s)", err)
	}

	return version, nil
}

func String() string {
	return fmt.Sprintf("nameVersion: %s, namespace: %s, rhelVersion: %.1f",
		info.nameVersion, info.namespace, info.rhelVersion,
	)
}

// GetNamespace
func GetNamespace() string {
	return info.namespace
}

// GetNameVersion
func GetNameVersion() string {
	return info.nameVersion
}

// GetRhelVersion
func GetRhelVersion() float64 {
	return info.rhelVersion
}

// isLocalRuntime
func isLocalRuntime() bool {
	return os.Getenv(consts.EnvOperRunMode) == consts.EnvOperRunModeTest
}
